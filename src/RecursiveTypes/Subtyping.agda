module RecursiveTypes.Subtyping where

open import Data.Empty
  using ( ⊥ ; ⊥-elim )

open import Data.Integer
  using ( +_ )

open import Data.Product
  using ( Σ ; _,_ ; proj₁ ; proj₂ ; _×_ ; Σ-syntax ; map ; uncurry )

open import Data.Sum
  using ( _⊎_ ; inj₁ ; inj₂ ; [_,_] )

open import Function
  using ( id ; _∘_ )

open import Relation.Binary
  using ( Reflexive ; Transitive )

open import Relation.Binary.HeterogeneousEquality
  using ( _≅_ ; refl )

open import Relation.Binary.PropositionalEquality
  using ( _≡_ ; _≢_ ; refl ; cong ; cong₂ )

open import Relation.Nullary
  using ( ¬_ )

open import RecursiveTypes.Semantics
  hiding ( _×_ )

infix 8 _≤_ _∞≤_

-- Subtyping, with the rule for pairs defined coinductively.  The paper
-- defines all of these rules coinductively, but as all rules clearly
-- deconstruct at least one of the types into its components, only the
-- one which operates on the point of recursion needs to be coinductive
-- to ensure infinite types are able to subtype one another.
mutual
  data _≤_ : Type → Type → Set where
    int : Int ≤ Int
    pair : ∀ {A B C D}
           → A ∞≤ C → B ∞≤ D → A ⨯ B ≤ C ⨯ D
    left : ∀ {A B C} → A ≤ B → A ≤ B ∨ C
    right : ∀ {A B C} → A ≤ C → A ≤ B ∨ C
    union : ∀ {A B C} → A ≤ C → B ≤ C → A ∨ B ≤ C
    bottom : ∀ {A B} → ¬ ⟦ A ⟧ → A ≤ B

  -- As with the coinductive types, the point of recursion is defined
  -- using a coinductive record declaration.
  record _∞≤_ (A B : ∞Type) : Set where
    coinductive
    constructor delay
    field sub : type A ≤ type B

open _∞≤_ public

-- A lemma that the ordering of unions in the subtype does not affect
-- the subtype relation.
flip-union₁ : ∀ {A B C} → A ∨ B ≤ C → B ∨ A ≤ C
flip-union₁ (left p) = left (flip-union₁ p)
flip-union₁ (right p) = right (flip-union₁ p)
flip-union₁ (union p q) = union q p
flip-union₁ (bottom ¬x) = bottom (¬x ∘ [ inj₂ , inj₁ ])

-- A lemma that the ordering of unions in the supertype does not affect
-- the subtype relation.
flip-union₂ : ∀ {A B C} → A ≤ B ∨ C → A ≤ C ∨ B
flip-union₂ (left p) = right p
flip-union₂ (right p) = left p
flip-union₂ (union p q) = union (flip-union₂ p) (flip-union₂ q)
flip-union₂ (bottom ¬x) = bottom ¬x

-- Subtyping is naturally reflexive.
mutual
  reflexive : Reflexive _≤_
  reflexive {Int}   = int
  reflexive {A ⨯ B} = pair ∞reflexive ∞reflexive
  reflexive {A ∨ B} = union (left reflexive) (right reflexive)

  -- Again, we use a copattern to enforce productivity.
  ∞reflexive : Reflexive _∞≤_
  sub ∞reflexive = reflexive

-- Subsets between the semantic interpretation of the coinductive types
-- A and B is defined as a proof that, for every value x in A, there
-- exists a corresponding y in B such that the embedding of x and y into
-- the Value type are equivalent.  Every Value that can be generated by
-- the embed function for the type A can also be generated by embed for
-- the type B.
⟦_⟧⊆⟦_⟧ : Type → Type → Set
⟦ A ⟧⊆⟦ B ⟧ = (x : ⟦ A ⟧) → Σ[ y ∈ ⟦ B ⟧ ] embed x ≡ embed y

⟦_⟧⊈⟦_⟧ : Type → Type → Set
⟦ A ⟧⊈⟦ B ⟧ = Σ[ x ∈ ⟦ A ⟧ ] ((y : ⟦ B ⟧) → embed x ≢ embed y)

-- Subtyping is a sound argument for this new subset relation: a proof
-- of subtyping between types A and B implies a proof that their
-- meanings are subsets.
{-# TERMINATING #-}
≤-sound : ∀ {A B} → A ≤ B → ⟦ A ⟧⊆⟦ B ⟧
≤-sound int         x        = x , refl
≤-sound (left p)    x        with ≤-sound p x
≤-sound (left p)    x        | y , q = inj₁ y , q
≤-sound (right p)   x        with ≤-sound p x
≤-sound (right p)   x        | y , q = inj₂ y , q
≤-sound (pair p q)  (w , x)  with ≤-sound (sub p) w | ≤-sound (sub q) x
≤-sound (pair p q)  (w , x)  | y , r | z , s = (y , z) , cong₂ _,_ r s
≤-sound (union p q) (inj₁ x) = ≤-sound p x
≤-sound (union p q) (inj₂ y) = ≤-sound q y
≤-sound (bottom ¬x) x        = ⊥-elim (¬x x)

-- Subtyping is naturally transitive.
mutual
  transitive : Transitive _≤_
  transitive p           int         = p
  transitive p           (left q)    = left (transitive p q)
  transitive p           (right q)   = right (transitive p q)
  transitive (left p)    (union q r) = transitive p q
  transitive (right p)   (union q r) = transitive p r
  transitive (pair p q)  (pair r s)  = pair (∞transitive p r)
                                            (∞transitive q s)
  transitive (union p q) r           = union (transitive p r)
                                             (transitive q r)
  transitive (bottom ¬x) q           = bottom ¬x
  transitive p           (bottom ¬x) = bottom (¬x ∘ proj₁ ∘ ≤-sound p)

  -- A copattern is also used here.
  ∞transitive : Transitive _∞≤_
  sub (∞transitive p q) = transitive (sub p) (sub q)

-- Completion workspace.
open import Relation.Nullary
  using ( Dec ; yes ; no )

infix 8 _≰_ _≤?_

data _≰_ : Type → Type → Set where
  int-≰-pair : ∀ {A B} → Int ≰ A ⨯ B
  pair-≰-int : ∀ {A B} → ⟦ type A ⟧ → ⟦ type B ⟧ → A ⨯ B ≰ Int
  pair₁ : ∀ {A B C D} → type A ≰ type C → ⟦ type B ⟧ → A ⨯ B ≰ C ⨯ D
  pair₂ : ∀ {A B C D} → type B ≰ type D → ⟦ type A ⟧ → A ⨯ B ≰ C ⨯ D
  neither-int : ∀ {A B} → Int ≰ A → Int ≰ B → Int ≰ A ∨ B
  neither-pair : ∀ {A B C D} → A ⨯ B ≰ C → A ⨯ B ≰ D → A ⨯ B ≰ C ∨ D
  union₁ : ∀ {A B C} → A ≰ C → A ∨ B ≰ C
  union₂ : ∀ {A B C} → B ≰ C → A ∨ B ≰ C

inhabited : ∀ {A B} → A ≰ B → ⟦ A ⟧
inhabited int-≰-pair = + 0
inhabited (pair-≰-int x y) = x , y
inhabited (pair₁ p x) = inhabited p , x
inhabited (pair₂ p x) = x , inhabited p
inhabited (neither-int p q) = inhabited q
inhabited (neither-pair p q) = inhabited q
inhabited (union₁ p) = inj₁ (inhabited p)
inhabited (union₂ p) = inj₂ (inhabited p)

uninhabited : ∀ {A B} → ¬ ⟦ A ⟧ → ¬ ⟦ B ⟧ → ¬ ⟦ A ∨ B ⟧
uninhabited ¬x ¬y (inj₁ x) = ¬x x
uninhabited ¬x ¬y (inj₂ y) = ¬y y

uninhabited₁ : ∀ A B → ¬ ⟦ type A ⟧ → ¬ ⟦ A ⨯ B ⟧
uninhabited₁ A B ¬x (x , y) = ¬x x

uninhabited₂ : ∀ A B → ¬ ⟦ type B ⟧ → ¬ ⟦ A ⨯ B ⟧
uninhabited₂ A B ¬y (x , y) = ¬y y

{-# TERMINATING #-}
inhabited? : ∀ A → Dec ⟦ A ⟧
inhabited? Int = yes (+ 0)
inhabited? (A ⨯ B) with inhabited? (type A) | inhabited? (type B)
inhabited? (A ⨯ B) | yes x | yes y = yes (x , y)
inhabited? (A ⨯ B) | no ¬x | y = no (uninhabited₁ A B ¬x)
inhabited? (A ⨯ B) | x | no ¬y = no (uninhabited₂ A B ¬y)
inhabited? (A ∨ B) with inhabited? A | inhabited? B
inhabited? (A ∨ B) | yes x | y = yes (inj₁ x)
inhabited? (A ∨ B) | x | yes y = yes (inj₂ y)
inhabited? (A ∨ B) | no ¬x | no ¬y = no (uninhabited ¬x ¬y)

union-sub₁ : ∀ {A B C} → A ∨ B ≤ C → A ≤ C
union-sub₁ (left p) = left (union-sub₁ p)
union-sub₁ (right p) = right (union-sub₁ p)
union-sub₁ (union p q) = p
union-sub₁ (bottom ¬x) = bottom (¬x ∘ inj₁)

union-sub₂ : ∀ {A B C} → A ∨ B ≤ C → B ≤ C
union-sub₂ (left p) = left (union-sub₂ p)
union-sub₂ (right p) = right (union-sub₂ p)
union-sub₂ (union p q) = q
union-sub₂ (bottom ¬x) = bottom (¬x ∘ inj₂)

{-# TERMINATING #-}
_≤?_ : ∀ A B → A ≤ B ⊎ A ≰ B
Int ≤? Int = inj₁ int
A ⨯ B ≤? Int with inhabited? (type A) | inhabited? (type B)
A ⨯ B ≤? Int | yes x | yes y = inj₂ (pair-≰-int x y)
A ⨯ B ≤? Int | no ¬x | y? = inj₁ (bottom λ { (x , y) → ¬x x })
A ⨯ B ≤? Int | x? | no ¬y = inj₁ (bottom λ { (x , y) → ¬y y })
Int ≤? A₁ ⨯ B = inj₂ int-≰-pair
A ⨯ B ≤? C ⨯ D with type A ≤? type C | type B ≤? type D | inhabited? (type A) | inhabited? (type B)
A ⨯ B ≤? C ⨯ D | inj₁ p | inj₁ q | x? | y? = inj₁ (pair (delay p) (delay q))
A ⨯ B ≤? C ⨯ D | inj₂ p | q? | x? | yes y = inj₂ (pair₁ p y)
A ⨯ B ≤? C ⨯ D | inj₂ p | q? | x? | no ¬y = inj₁ (bottom λ { (x , y) → ¬y y })
A ⨯ B ≤? C ⨯ D | p? | inj₂ q | yes x | y? = inj₂ (pair₂ q x)
A ⨯ B ≤? C ⨯ D | p? | inj₂ q | no ¬x | y? = inj₁ (bottom λ { (x , y) → ¬x x })
A ≤? B ∨ C with A ≤? B | A ≤? C
A ≤? B ∨ C | inj₁ p | q? = inj₁ (left p)
A ≤? B ∨ C | p? | inj₁ q = inj₁ (right q)
Int ≤? B ∨ C | inj₂ p | inj₂ q = inj₂ (neither-int p q)
A₁ ⨯ A₂ ≤? B ∨ C | inj₂ p | inj₂ q = inj₂ (neither-pair p q)
A₁ ∨ A₂ ≤? B ∨ C | p? | q? with A₁ ≤? (B ∨ C) | A₂ ≤? (B ∨ C)
A₁ ∨ A₂ ≤? B ∨ C | p? | q? | inj₁ r | inj₁ s = inj₁ (union r s)
A₁ ∨ A₂ ≤? B ∨ C | p? | q? | inj₂ r | s? = inj₂ (union₁ r)
A₁ ∨ A₂ ≤? B ∨ C | p? | q? | r? | inj₂ s = inj₂ (union₂ s)
A ∨ B ≤? C with A ≤? C | B ≤? C
A ∨ B ≤? C | inj₁ p | inj₁ q = inj₁ (union p q)
A ∨ B ≤? C | p | inj₂ q = inj₂ (union₂ q)
A ∨ B ≤? C | inj₂ p | q = inj₂ (union₁ p)

≰→¬≤ : ∀ {A B} → A ≰ B → ¬ A ≤ B
≰→¬≤ int-≰-pair (bottom ¬x) = ¬x (+ 0)
≰→¬≤ (pair-≰-int x y) (bottom ¬x) = ¬x (x , y)
≰→¬≤ (pair₁ p x) (pair q r) = ≰→¬≤ p (sub q)
≰→¬≤ (pair₁ p x) (bottom ¬x) = ¬x (inhabited p , x)
≰→¬≤ (pair₂ p y) (pair q r) = ≰→¬≤ p (sub r)
≰→¬≤ (pair₂ p y) (bottom ¬x) = ¬x (y , inhabited p)
≰→¬≤ (neither-int p q) (left r) = ≰→¬≤ p r
≰→¬≤ (neither-int p q) (right r) = ≰→¬≤ q r
≰→¬≤ (neither-int p q) (bottom ¬x) = ¬x (inhabited p)
≰→¬≤ (neither-pair p q) (left r) = ≰→¬≤ p r
≰→¬≤ (neither-pair p q) (right r) = ≰→¬≤ q r
≰→¬≤ (neither-pair p q) (bottom ¬x) = ¬x (inhabited p)
≰→¬≤ (union₁ p) q = ≰→¬≤ p (union-sub₁ q)
≰→¬≤ (union₂ p) q = ≰→¬≤ p (union-sub₂ q)

-- Corollary
≤→¬≰ : ∀ {A B} → A ≤ B → ¬ A ≰ B
≤→¬≰ p q = ≰→¬≤ q p

-- The following four lemmas demonstrate that the union constructors are
-- strictly more powerful than the neither constructors: given the
-- components of a union constructor, the components of a neither
-- constructor can be inferred.  The reverse is not true: hence why
-- neither is split out into int and pair cases, with no case for a
-- union: that case should always be handled by one of the union
-- constructors instead.

-- Split a union proof into its left side.
split-union₁ : ∀ {A B C} → A ≰ B ∨ C → A ≰ B
split-union₁ (neither-int p q) = p
split-union₁ (neither-pair p q) = p
split-union₁ (union₁ p) = union₁ (split-union₁ p)
split-union₁ (union₂ p) = union₂ (split-union₁ p)

-- Split a union proof into its right side.
split-union₂ : ∀ {A B C} → A ≰ B ∨ C → A ≰ C
split-union₂ (neither-int p q) = q
split-union₂ (neither-pair p q) = q
split-union₂ (union₁ p) = union₁ (split-union₂ p)
split-union₂ (union₂ p) = union₂ (split-union₂ p)

-- If two types are not subtypes of a union, their union is not a
-- subtype of the left side of that union.
combine-union₁ : ∀ {A B C D} → A ≰ C ∨ D → B ≰ C ∨ D → A ∨ B ≰ C
combine-union₁ (neither-int p q) r = union₁ p
combine-union₁ (neither-pair p q) r = union₁ p
combine-union₁ (union₁ p) q = union₁ (union₁ (split-union₁ p))
combine-union₁ (union₂ p) q = union₂ (split-union₁ q)

-- If two types are not subtypes of a union, their union is not a
-- subtype of the right side of that union.
combine-union₂ : ∀ {A B C D} → A ≰ C ∨ D → B ≰ C ∨ D → A ∨ B ≰ D
combine-union₂ (neither-int p q) r = union₁ q
combine-union₂ (neither-pair p q) r = union₁ q
combine-union₂ (union₁ p) q = union₁ (union₁ (split-union₂ p))
combine-union₂ (union₂ p) q = union₂ (split-union₂ q)

eq-fst : ∀ {w x y z} → _≡_ {A = Value} (w , x) (y , z) → w ≡ y
eq-fst refl = refl

eq-snd : ∀ {w x y z} → _≡_ {A = Value} (w , x) (y , z) → x ≡ z
eq-snd refl = refl

int-equality : ∀ {A} {x : ⟦ Int ⟧} (y : ⟦ A ⟧) → embed x ≡ embed y → Int ≤ A
int-equality {Int} y p = int
int-equality {A ⨯ B} {x} (y , z) ()
int-equality {A ∨ B} {x} (inj₁ y) p = left (int-equality y p)
int-equality {A ∨ B} {x} (inj₂ z) p = right (int-equality z p)

≰-sound : ∀ {A B} → A ≰ B → ⟦ A ⟧⊈⟦ B ⟧
≰-sound int-≰-pair = + 0 , λ { (y , z) () }
≰-sound (pair-≰-int x y) = (x , y) , λ { z () }
≰-sound (pair₁ p x) with ≰-sound p
≰-sound (pair₁ p x) | (w , f) = (w , x) , λ { (y , z) q → f y (eq-fst q) }
≰-sound (pair₂ {A} {B} p x) with ≰-sound p
≰-sound (pair₂ p x) | (w , f) = (x , w) , λ { (y , z) q → f z (eq-snd q) }
≰-sound (neither-int p q) = map id ([_,_] (λ z → ≰→¬≤ p ∘ int-equality z)) (≰-sound q)
≰-sound (neither-pair p q) with ≰-sound p | ≰-sound q
≰-sound (neither-pair {C = Int} p q) | x , f | (w , y) , g = (w , y) , [ (λ z ()) , g ]
≰-sound (neither-pair {D = Int} p q) | (w , x) , f | y , g = (w , x) , [ f , (λ z ()) ]
≰-sound (neither-pair p q) | x , f | y , g = {!!}
≰-sound (union₁ p) = map inj₁ id (≰-sound p)
≰-sound (union₂ p) = map inj₂ id (≰-sound p)

IntPair = delay Int ⨯ delay Int

≰-complete : Σ[ A ∈ Type ] Σ[ B ∈ Type ] ⟦ A ⟧⊆⟦ B ⟧ × ¬ A ≤ B
≰-complete = delay (Int ∨ IntPair) ⨯ delay Int , IntPair ∨ delay IntPair ⨯ delay Int ,
             (λ { (inj₁ x , y) → inj₁ (x , y) , refl ; (inj₂ x , y) → inj₂ (x , y) , refl }) ,
             ≰→¬≤ (neither-pair (pair₁ (union₂ (pair-≰-int (+ 0) (+ 0))) (+ 0)) (pair₁ (union₁ int-≰-pair) (+ 0)))

-- Completion is more difficult, particularly because our input is a
-- function, and the only thing that can be done with a function is
-- apply it (assuming an appropriate input is available).
≤-complete : ∀ {A B} → ⟦ A ⟧⊆⟦ B ⟧ → A ≤ B
≤-complete {A} {B} f with A ≤? B
≤-complete {A} {B} f | inj₁ p = p
≤-complete {A} {B} f | inj₂ q with ≰-sound q
≤-complete f | inj₂ q | x , g = ⊥-elim (uncurry g (f x))

false : ⊥
false with ≰-complete
false | A , B , p , ¬q = ¬q (≤-complete p)
